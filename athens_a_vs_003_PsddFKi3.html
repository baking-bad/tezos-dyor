<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/diff2html/2.7.0/diff2html.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/diff2html/2.7.0/diff2html.min.js"></script>
</head>
<body>
<div id="diff"></div>
<script>
  var text = "--- constants_repr.ml\n+++ constants_repr.ml\n@@ -94,6 +94,7 @@\n   endorsement_reward: Tez_repr.t ;\n   cost_per_byte: Tez_repr.t ;\n   hard_storage_limit_per_operation: Z.t ;\n+  test_chain_duration: int64 ;  (* in seconds *)\n }\n \n let default = {\n@@ -105,8 +106,8 @@\n   time_between_blocks =\n     List.map Period_repr.of_seconds_exn [ 60L ; 75L ] ;\n   endorsers_per_block = 32 ;\n-  hard_gas_limit_per_operation = Z.of_int 400_000 ;\n-  hard_gas_limit_per_block = Z.of_int 4_000_000 ;\n+  hard_gas_limit_per_operation = Z.of_int 800_000 ;\n+  hard_gas_limit_per_block = Z.of_int 8_000_000 ;\n   proof_of_work_threshold =\n     Int64.(sub (shift_left 1L 46) 1L) ;\n   tokens_per_roll =\n@@ -124,9 +125,8 @@\n   endorsement_reward = Tez_repr.(mul_exn one 2) ;\n   hard_storage_limit_per_operation = Z.of_int 60_000 ;\n   cost_per_byte = Tez_repr.of_mutez_exn 1_000L ;\n-}\n-\n-module CompareListInt = Compare.List (Compare.Int)\n+  test_chain_duration = Int64.mul 32768L 60L;\n+}\n \n let parametric_encoding =\n   let open Data_encoding in\n@@ -151,7 +151,8 @@\n           c.block_reward),\n          (c.endorsement_reward,\n           c.cost_per_byte,\n-          c.hard_storage_limit_per_operation))) )\n+          c.hard_storage_limit_per_operation,\n+          c.test_chain_duration))) )\n     (fun (( preserved_cycles,\n             blocks_per_cycle,\n             blocks_per_commitment,\n@@ -171,7 +172,8 @@\n             block_reward),\n            (endorsement_reward,\n             cost_per_byte,\n-            hard_storage_limit_per_operation))) ->\n+            hard_storage_limit_per_operation,\n+            test_chain_duration))) ->\n       { preserved_cycles ;\n         blocks_per_cycle ;\n         blocks_per_commitment ;\n@@ -192,6 +194,7 @@\n         endorsement_reward ;\n         cost_per_byte ;\n         hard_storage_limit_per_operation ;\n+        test_chain_duration ;\n       } )\n     (merge_objs\n        (obj9\n@@ -214,10 +217,11 @@\n              (req \"block_security_deposit\" Tez_repr.encoding)\n              (req \"endorsement_security_deposit\" Tez_repr.encoding)\n              (req \"block_reward\" Tez_repr.encoding))\n-          (obj3\n+          (obj4\n              (req \"endorsement_reward\" Tez_repr.encoding)\n              (req \"cost_per_byte\" Tez_repr.encoding)\n-             (req \"hard_storage_limit_per_operation\" z))))\n+             (req \"hard_storage_limit_per_operation\" z)\n+             (req \"test_chain_duration\" int64))))\n \n type t = {\n   fixed : fixed ;\n\n--- voting_period_repr.mli\n+++ voting_period_repr.mli\n@@ -23,6 +23,9 @@\n (*                                                                           *)\n (*****************************************************************************)\n \n+(** A voting period can be of 4 kinds and is uniquely identified as a counter\n+    since the root. *)\n+\n type t\n type voting_period = t\n val encoding: voting_period Data_encoding.t\n@@ -37,9 +40,9 @@\n val succ: voting_period -> voting_period\n \n type kind =\n-  | Proposal\n-  | Testing_vote\n-  | Testing\n-  | Promotion_vote\n+  | Proposal       (** protocols can be proposed *)\n+  | Testing_vote   (** a proposal can be voted *)\n+  | Testing        (** winning proposal is forked on a testnet *)\n+  | Promotion_vote (** activation can be voted *)\n \n val kind_encoding: kind Data_encoding.t\n\n--- gas_limit_repr.ml\n+++ gas_limit_repr.ml\n@@ -85,8 +85,8 @@\n \n let allocation_weight = Z.of_int 2\n let step_weight = Z.of_int 1\n-let read_base_weight = Z.of_int 50\n-let write_base_weight = Z.of_int 80\n+let read_base_weight = Z.of_int 100\n+let write_base_weight = Z.of_int 160\n let byte_read_weight = Z.of_int 10\n let byte_written_weight = Z.of_int 15\n \n\n--- michelson_v1_primitives.ml\n+++ michelson_v1_primitives.ml\n@@ -554,12 +554,12 @@\n let () =\n   register_error_kind\n     `Permanent\n-    ~id:\"unknownPrimitiveNameTypeError\"\n-    ~title: \"Unknown primitive name (typechecking error)\"\n+    ~id:\"michelson_v1.unknown_primitive_name\"\n+    ~title: \"Unknown primitive name\"\n     ~description:\n       \"In a script or data expression, a primitive was unknown.\"\n     ~pp:(fun ppf n -> Format.fprintf ppf \"Unknown primitive %s.\" n)\n-    Data_encoding.(obj1 (req \"wrongPrimitiveName\" string))\n+    Data_encoding.(obj1 (req \"wrong_primitive_name\" string))\n     (function\n       | Unknown_primitive_name got -> Some got\n       | _ -> None)\n@@ -567,13 +567,13 @@\n        Unknown_primitive_name got) ;\n   register_error_kind\n     `Permanent\n-    ~id:\"invalidPrimitiveNameCaseTypeError\"\n-    ~title: \"Invalid primitive name case (typechecking error)\"\n+    ~id:\"michelson_v1.invalid_primitive_name_case\"\n+    ~title: \"Invalid primitive name case\"\n     ~description:\n       \"In a script or data expression, a primitive name is \\\n        neither uppercase, lowercase or capitalized.\"\n     ~pp:(fun ppf n -> Format.fprintf ppf \"Primitive %s has invalid case.\" n)\n-    Data_encoding.(obj1 (req \"wrongPrimitiveName\" string))\n+    Data_encoding.(obj1 (req \"wrong_primitive_name\" string))\n     (function\n       | Invalid_case name -> Some name\n       | _ -> None)\n@@ -581,8 +581,8 @@\n        Invalid_case name) ;\n   register_error_kind\n     `Permanent\n-    ~id:\"invalidPrimitiveNameTypeErro\"\n-    ~title: \"Invalid primitive name (typechecking error)\"\n+    ~id:\"michelson_v1.invalid_primitive_name\"\n+    ~title: \"Invalid primitive name\"\n     ~description:\n       \"In a script or data expression, a primitive name is \\\n        unknown or has a wrong case.\"\n\n--- contract_repr.mli\n+++ contract_repr.mli\n@@ -76,10 +76,9 @@\n \n val rpc_arg : contract RPC_arg.arg\n \n-module Index : sig\n-  include Storage_description.INDEX with type t = t\n-  val contract_prefix: string -> string list\n-  val pkh_prefix_ed25519: string -> string list\n-  val pkh_prefix_secp256k1: string -> string list\n-  val pkh_prefix_p256: string -> string list\n-end\n+module Index : Storage_description.INDEX with type t = t\n+\n+(**/**)\n+\n+(** Only for stitching from proto_003 to proto_004 *)\n+val old_contract_of_path: string list -> contract option\n\n--- contract_repr.ml\n+++ contract_repr.ml\n@@ -172,39 +172,53 @@\n     ()\n \n module Index = struct\n+\n   type t = contract\n-  let path_length =\n-\n-    assert Compare.Int.(Signature.Public_key_hash.path_length =\n-                        1 + Contract_hash.path_length) ;\n-    Signature.Public_key_hash.path_length\n+\n+  let path_length = 7\n+\n   let to_path c l =\n-    match c with\n-    | Implicit k ->\n-        Signature.Public_key_hash.to_path k l\n-    | Originated h ->\n-        \"originated\" :: Contract_hash.to_path h l\n+    let raw_key = Data_encoding.Binary.to_bytes_exn encoding c in\n+    let `Hex key = MBytes.to_hex raw_key in\n+    let `Hex index_key = MBytes.to_hex (Raw_hashes.blake2b raw_key) in\n+    String.sub index_key 0 2 ::\n+    String.sub index_key 2 2 ::\n+    String.sub index_key 4 2 ::\n+    String.sub index_key 6 2 ::\n+    String.sub index_key 8 2 ::\n+    String.sub index_key 10 2 ::\n+    key ::\n+    l\n+\n   let of_path = function\n-    | \"originated\" :: key -> begin\n-        match Contract_hash.of_path key with\n-        | None -> None\n-        | Some h -> Some (Originated h)\n-      end\n-    | key -> begin\n-        match Signature.Public_key_hash.of_path key with\n-        | None -> None\n-        | Some h -> Some (Implicit h)\n-      end\n-  let contract_prefix s =\n-    \"originated\" :: Contract_hash.prefix_path s\n-  let pkh_prefix_ed25519 s =\n-    Ed25519.Public_key_hash.prefix_path s\n-  let pkh_prefix_secp256k1 s =\n-    Secp256k1.Public_key_hash.prefix_path s\n-  let pkh_prefix_p256 s =\n-    P256.Public_key_hash.prefix_path s\n+    | [] | [_] | [_;_] | [_;_;_] | [_;_;_;_] | [_;_;_;_;_] | [_;_;_;_;_;_]\n+    | _::_::_::_::_::_::_::_::_ ->\n+        None\n+    | [ index1 ; index2 ; index3 ; index4 ; index5 ; index6 ; key ] ->\n+        let raw_key = MBytes.of_hex (`Hex key) in\n+        let `Hex index_key = MBytes.to_hex (Raw_hashes.blake2b raw_key) in\n+        assert Compare.String.(String.sub index_key 0 2 = index1) ;\n+        assert Compare.String.(String.sub index_key 2 2 = index2) ;\n+        assert Compare.String.(String.sub index_key 4 2 = index3) ;\n+        assert Compare.String.(String.sub index_key 6 2 = index4) ;\n+        assert Compare.String.(String.sub index_key 8 2 = index5) ;\n+        assert Compare.String.(String.sub index_key 10 2 = index6) ;\n+        Data_encoding.Binary.of_bytes encoding raw_key\n \n   let rpc_arg = rpc_arg\n   let encoding = encoding\n   let compare = compare\n+\n end\n+\n+let old_contract_of_path = function\n+  | \"originated\" :: key -> begin\n+      match Contract_hash.of_path key with\n+      | None -> None\n+      | Some h -> Some (Originated h)\n+    end\n+  | key -> begin\n+      match Signature.Public_key_hash.of_path key with\n+      | None -> None\n+      | Some h -> Some (Implicit h)\n+    end\n\n--- vote_repr.mli\n+++ vote_repr.mli\n@@ -23,7 +23,10 @@\n (*                                                                           *)\n (*****************************************************************************)\n \n+(** a protocol change proposal *)\n type proposal = Protocol_hash.t\n \n+(** votes can be for, against or neutral.\n+    Neutral serves to count towards a quorum *)\n type ballot = Yay | Nay | Pass\n val ballot_encoding: ballot Data_encoding.t\n\n--- vote_repr.ml\n+++ vote_repr.ml\n@@ -23,11 +23,8 @@\n (*                                                                           *)\n (*****************************************************************************)\n \n-(* a protocol change proposal *)\n type proposal = Protocol_hash.t\n \n-(* votes can be for, against or neutral.\n-   Neutral serves to count towards a quorum *)\n type ballot = Yay | Nay | Pass\n \n let ballot_encoding =\n\n--- operation_repr.ml\n+++ operation_repr.ml\n@@ -253,7 +253,7 @@\n         name = \"origination\" ;\n         encoding =\n           (obj6\n-             (req \"managerPubkey\" Signature.Public_key_hash.encoding)\n+             (req \"manager_pubkey\" Signature.Public_key_hash.encoding)\n              (req \"balance\" Tez_repr.encoding)\n              (dft \"spendable\" bool true)\n              (dft \"delegatable\" bool true)\n\n--- parameters_repr.mli\n+++ parameters_repr.mli\n@@ -46,3 +46,32 @@\n \n val encoding: t Data_encoding.t\n val constants_encoding: Constants_repr.parametric Data_encoding.t\n+\n+\n+(* Only for stitching form proto_003 *)\n+module Proto_003 : sig\n+  type parametric = {\n+    preserved_cycles: int ;\n+    blocks_per_cycle: int32 ;\n+    blocks_per_commitment: int32 ;\n+    blocks_per_roll_snapshot: int32 ;\n+    blocks_per_voting_period: int32 ;\n+    time_between_blocks: Period_repr.t list ;\n+    endorsers_per_block: int ;\n+    hard_gas_limit_per_operation: Z.t ;\n+    hard_gas_limit_per_block: Z.t ;\n+    proof_of_work_threshold: int64 ;\n+    tokens_per_roll: Tez_repr.t ;\n+    michelson_maximum_type_size: int;\n+    seed_nonce_revelation_tip: Tez_repr.t ;\n+    origination_size: int ;\n+    block_security_deposit: Tez_repr.t ;\n+    endorsement_security_deposit: Tez_repr.t ;\n+    block_reward: Tez_repr.t ;\n+    endorsement_reward: Tez_repr.t ;\n+    cost_per_byte: Tez_repr.t ;\n+    hard_storage_limit_per_operation: Z.t ;\n+  }\n+\n+  val constants_encoding : parametric Data_encoding.encoding\n+end\n\n--- parameters_repr.ml\n+++ parameters_repr.ml\n@@ -156,6 +156,9 @@\n        and hard_storage_limit_per_operation =\n          opt Compare.Z.(=)\n            default.hard_storage_limit_per_operation c.hard_storage_limit_per_operation\n+       and test_chain_duration =\n+         opt Compare.Int64.(=)\n+           default.test_chain_duration c.test_chain_duration\n        in\n        (( preserved_cycles,\n           blocks_per_cycle,\n@@ -176,7 +179,8 @@\n           block_reward),\n          (endorsement_reward,\n           cost_per_byte,\n-          hard_storage_limit_per_operation))))\n+          hard_storage_limit_per_operation,\n+          test_chain_duration))))\n     (fun (( preserved_cycles,\n             blocks_per_cycle,\n             blocks_per_commitment,\n@@ -196,7 +200,8 @@\n             block_reward),\n            (endorsement_reward,\n             cost_per_byte,\n-            hard_storage_limit_per_operation))) ->\n+            hard_storage_limit_per_operation,\n+            test_chain_duration))) ->\n       let unopt def = function None -> def | Some v -> v in\n       let default = Constants_repr.default in\n       { Constants_repr.preserved_cycles =\n@@ -240,6 +245,8 @@\n           unopt default.cost_per_byte cost_per_byte ;\n         hard_storage_limit_per_operation =\n           unopt default.hard_storage_limit_per_operation hard_storage_limit_per_operation ;\n+        test_chain_duration =\n+          unopt default.test_chain_duration test_chain_duration ;\n       } )\n     (merge_objs\n        (obj9\n@@ -262,10 +269,11 @@\n              (opt \"block_security_deposit\" Tez_repr.encoding)\n              (opt \"endorsement_security_deposit\" Tez_repr.encoding)\n              (opt \"block_reward\" Tez_repr.encoding))\n-          (obj3\n+          (obj4\n              (opt \"endorsement_reward\" Tez_repr.encoding)\n              (opt \"cost_per_byte\" Tez_repr.encoding)\n-             (opt \"hard_storage_limit_per_operation\" z))))\n+             (opt \"hard_storage_limit_per_operation\" z)\n+             (opt \"test_chain_duration\" int64))))\n \n let encoding =\n   let open Data_encoding in\n@@ -288,3 +296,160 @@\n           (opt \"security_deposit_ramp_up_cycles\" int31)\n           (opt \"no_reward_cycles\" int31))\n        constants_encoding)\n+\n+\n+(* Only for stitching form proto_003 *)\n+module Proto_003 = struct\n+\n+  (* This is an excerpt from constants_repr.ml of proto_003_PsddFKi3 *)\n+\n+  type parametric = {\n+    preserved_cycles: int ;\n+    blocks_per_cycle: int32 ;\n+    blocks_per_commitment: int32 ;\n+    blocks_per_roll_snapshot: int32 ;\n+    blocks_per_voting_period: int32 ;\n+    time_between_blocks: Period_repr.t list ;\n+    endorsers_per_block: int ;\n+    hard_gas_limit_per_operation: Z.t ;\n+    hard_gas_limit_per_block: Z.t ;\n+    proof_of_work_threshold: int64 ;\n+    tokens_per_roll: Tez_repr.t ;\n+    michelson_maximum_type_size: int;\n+    seed_nonce_revelation_tip: Tez_repr.t ;\n+    origination_size: int ;\n+    block_security_deposit: Tez_repr.t ;\n+    endorsement_security_deposit: Tez_repr.t ;\n+    block_reward: Tez_repr.t ;\n+    endorsement_reward: Tez_repr.t ;\n+    cost_per_byte: Tez_repr.t ;\n+    hard_storage_limit_per_operation: Z.t ;\n+  }\n+\n+  let default = {\n+    preserved_cycles = 5 ;\n+    blocks_per_cycle = 4096l ;\n+    blocks_per_commitment = 32l ;\n+    blocks_per_roll_snapshot = 256l ;\n+    blocks_per_voting_period = 32768l ;\n+    time_between_blocks =\n+      List.map Period_repr.of_seconds_exn [ 60L ; 75L ] ;\n+    endorsers_per_block = 32 ;\n+    hard_gas_limit_per_operation = Z.of_int 400_000 ;\n+    hard_gas_limit_per_block = Z.of_int 4_000_000 ;\n+    proof_of_work_threshold =\n+      Int64.(sub (shift_left 1L 46) 1L) ;\n+    tokens_per_roll =\n+      Tez_repr.(mul_exn one 10_000) ;\n+    michelson_maximum_type_size = 1000 ;\n+    seed_nonce_revelation_tip = begin\n+      match Tez_repr.(one /? 8L) with\n+      | Ok c -> c\n+      | Error _ -> assert false\n+    end ;\n+    origination_size = 257 ;\n+    block_security_deposit = Tez_repr.(mul_exn one 512) ;\n+    endorsement_security_deposit = Tez_repr.(mul_exn one 64) ;\n+    block_reward = Tez_repr.(mul_exn one 16) ;\n+    endorsement_reward = Tez_repr.(mul_exn one 2) ;\n+    hard_storage_limit_per_operation = Z.of_int 60_000 ;\n+    cost_per_byte = Tez_repr.of_mutez_exn 1_000L ;\n+  }\n+\n+  (* This is an excerpt from parameters_repr.ml of proto_003_PsddFKi3:\n+     the encoder was removed and the default redirected to the one above *)\n+\n+  let constants_encoding =\n+    let open Data_encoding in\n+    conv\n+      (fun (_c : parametric) -> assert false)\n+      (fun (( preserved_cycles,\n+              blocks_per_cycle,\n+              blocks_per_commitment,\n+              blocks_per_roll_snapshot,\n+              blocks_per_voting_period,\n+              time_between_blocks,\n+              endorsers_per_block,\n+              hard_gas_limit_per_operation,\n+              hard_gas_limit_per_block),\n+            ((proof_of_work_threshold,\n+              tokens_per_roll,\n+              michelson_maximum_type_size,\n+              seed_nonce_revelation_tip,\n+              origination_size,\n+              block_security_deposit,\n+              endorsement_security_deposit,\n+              block_reward),\n+             (endorsement_reward,\n+              cost_per_byte,\n+              hard_storage_limit_per_operation))) ->\n+        let unopt def = function None -> def | Some v -> v in\n+        { preserved_cycles =\n+            unopt default.preserved_cycles preserved_cycles ;\n+          blocks_per_cycle =\n+            unopt default.blocks_per_cycle blocks_per_cycle ;\n+          blocks_per_commitment =\n+            unopt default.blocks_per_commitment blocks_per_commitment ;\n+          blocks_per_roll_snapshot =\n+            unopt default.blocks_per_roll_snapshot blocks_per_roll_snapshot ;\n+          blocks_per_voting_period =\n+            unopt default.blocks_per_voting_period blocks_per_voting_period ;\n+          time_between_blocks =\n+            unopt default.time_between_blocks @@\n+            time_between_blocks ;\n+          endorsers_per_block =\n+            unopt default.endorsers_per_block endorsers_per_block ;\n+          hard_gas_limit_per_operation =\n+            unopt default.hard_gas_limit_per_operation hard_gas_limit_per_operation ;\n+          hard_gas_limit_per_block =\n+            unopt default.hard_gas_limit_per_block hard_gas_limit_per_block ;\n+          proof_of_work_threshold =\n+            unopt default.proof_of_work_threshold proof_of_work_threshold ;\n+          tokens_per_roll =\n+            unopt default.tokens_per_roll tokens_per_roll ;\n+          michelson_maximum_type_size =\n+            unopt default.michelson_maximum_type_size michelson_maximum_type_size ;\n+          seed_nonce_revelation_tip =\n+            unopt default.seed_nonce_revelation_tip seed_nonce_revelation_tip ;\n+          origination_size =\n+            unopt default.origination_size origination_size ;\n+          block_security_deposit =\n+            unopt default.block_security_deposit block_security_deposit ;\n+          endorsement_security_deposit =\n+            unopt default.endorsement_security_deposit endorsement_security_deposit ;\n+          block_reward =\n+            unopt default.block_reward block_reward ;\n+          endorsement_reward =\n+            unopt default.endorsement_reward endorsement_reward ;\n+          cost_per_byte =\n+            unopt default.cost_per_byte cost_per_byte ;\n+          hard_storage_limit_per_operation =\n+            unopt default.hard_storage_limit_per_operation hard_storage_limit_per_operation ;\n+        } )\n+      (merge_objs\n+         (obj9\n+            (opt \"preserved_cycles\" uint8)\n+            (opt \"blocks_per_cycle\" int32)\n+            (opt \"blocks_per_commitment\" int32)\n+            (opt \"blocks_per_roll_snapshot\" int32)\n+            (opt \"blocks_per_voting_period\" int32)\n+            (opt \"time_between_blocks\" (list Period_repr.encoding))\n+            (opt \"endorsers_per_block\" uint16)\n+            (opt \"hard_gas_limit_per_operation\" z)\n+            (opt \"hard_gas_limit_per_block\" z))\n+         (merge_objs\n+            (obj8\n+               (opt \"proof_of_work_threshold\" int64)\n+               (opt \"tokens_per_roll\" Tez_repr.encoding)\n+               (opt \"michelson_maximum_type_size\" uint16)\n+               (opt \"seed_nonce_revelation_tip\" Tez_repr.encoding)\n+               (opt \"origination_size\" int31)\n+               (opt \"block_security_deposit\" Tez_repr.encoding)\n+               (opt \"endorsement_security_deposit\" Tez_repr.encoding)\n+               (opt \"block_reward\" Tez_repr.encoding))\n+            (obj3\n+               (opt \"endorsement_reward\" Tez_repr.encoding)\n+               (opt \"cost_per_byte\" Tez_repr.encoding)\n+               (opt \"hard_storage_limit_per_operation\" z))))\n+\n+end\n\n--- raw_context.mli\n+++ raw_context.mli\n@@ -58,15 +58,15 @@\n   fitness: Fitness.t ->\n   Context.t -> context tzresult Lwt.t\n \n-type 'a previous_protocol =\n-  | Genesis of 'a\n-  | Alpha_002\n+type previous_protocol =\n+  | Genesis of Parameters_repr.t\n+  | Alpha_003\n \n val prepare_first_block:\n   level:int32 ->\n   timestamp:Time.t ->\n   fitness:Fitness.t ->\n-  Context.t -> (Parameters_repr.t previous_protocol * context) tzresult Lwt.t\n+  Context.t -> (previous_protocol * context) tzresult Lwt.t\n \n val activate: context -> Protocol_hash.t -> t Lwt.t\n val fork_test_chain: context -> Protocol_hash.t -> Time.t -> t Lwt.t\n\n--- raw_context.ml\n+++ raw_context.ml\n@@ -318,7 +318,7 @@\n (* This key should always be populated for every version of the\n    protocol.  It's absence meaning that the context is empty. *)\n let version_key = [\"version\"]\n-let version_value = \"alpha_003\"\n+let version_value = \"athens_004\"\n \n let version = \"v1\"\n let first_level_key = [ version ; \"first_level\" ]\n@@ -414,6 +414,22 @@\n       | None ->\n           failwith \"Internal error: cannot parse constants in context.\"\n       | Some constants -> return constants\n+\n+(* Only for stitching from proto_003 *)\n+let get_003_constants ctxt =\n+  Context.get ctxt constants_key >>= function\n+  | None ->\n+      failwith \"Internal error: cannot read constants in context.\"\n+  | Some bytes ->\n+      match\n+        Data_encoding.Binary.of_bytes\n+          Parameters_repr.Proto_003.constants_encoding\n+          bytes\n+      with\n+      | None ->\n+          failwith \"Internal error: cannot parse constants in context.\"\n+      | Some constants ->\n+          return constants\n \n let patch_constants ctxt f =\n   let constants = f ctxt.constants in\n@@ -460,39 +476,69 @@\n     internal_nonces_used = Int_set.empty ;\n   }\n \n-type 'a previous_protocol =\n-  | Genesis of 'a\n-  | Alpha_002\n-\n-let check_first_block ctxt =\n-  Context.get ctxt version_key >>= function\n-  | None ->\n-      failwith \"Internal error: un-initialized context in check_first_block.\"\n-  | Some bytes ->\n-      let s = MBytes.to_string bytes in\n-      if Compare.String.(s = version_value) then\n-        failwith \"Internal error: previously initialized context.\"\n-      else if Compare.String.(s = \"genesis\") then\n-        return (Genesis ())\n-      else if Compare.String.(s = \"alpha_002\") then\n-        return Alpha_002\n-      else\n-        storage_error (Incompatible_protocol_version s)\n-\n-let prepare_first_block ~level ~timestamp ~fitness ctxt =\n-  check_first_block ctxt >>=? fun previous_protocol ->\n-  begin match previous_protocol with\n-    | Genesis () ->\n-        Lwt.return (Raw_level_repr.of_int32 level) >>=? fun first_level ->\n-        get_proto_param ctxt >>=? fun (param, ctxt) ->\n-        set_first_level ctxt first_level >>=? fun ctxt ->\n-        set_constants ctxt param.constants >>= fun ctxt ->\n-        return (Genesis param, ctxt)\n-    | Alpha_002 ->\n-        return (Alpha_002, ctxt)\n+type previous_protocol =\n+  | Genesis of Parameters_repr.t\n+  | Alpha_003\n+\n+let check_and_update_protocol_version ctxt =\n+  begin\n+    Context.get ctxt version_key >>= function\n+    | None ->\n+        failwith \"Internal error: un-initialized context in check_first_block.\"\n+    | Some bytes ->\n+        let s = MBytes.to_string bytes in\n+        if Compare.String.(s = version_value) then\n+          failwith \"Internal error: previously initialized context.\"\n+        else if Compare.String.(s = \"genesis\") then\n+          get_proto_param ctxt >>=? fun (param, ctxt) ->\n+          return (Genesis param, ctxt)\n+        else if Compare.String.(s = \"alpha_003\") then\n+          return (Alpha_003, ctxt)\n+        else\n+          storage_error (Incompatible_protocol_version s)\n   end >>=? fun (previous_proto, ctxt) ->\n   Context.set ctxt version_key\n     (MBytes.of_string version_value) >>= fun ctxt ->\n+  return (previous_proto, ctxt)\n+\n+let prepare_first_block ~level ~timestamp ~fitness ctxt =\n+  check_and_update_protocol_version ctxt >>=? fun (previous_proto, ctxt) ->\n+  begin\n+    match previous_proto with\n+    | Genesis param ->\n+        Lwt.return (Raw_level_repr.of_int32 level) >>=? fun first_level ->\n+        set_first_level ctxt first_level >>=? fun ctxt ->\n+        set_constants ctxt param.constants >>= fun ctxt ->\n+        return ctxt\n+    | Alpha_003 ->\n+        (* Migration: Since we changed `Constants_repr.parametric_encoding`,\n+           we need to upgrade the contents of `constants_key` in the context. *)\n+        get_003_constants ctxt >>=? fun (old : Parameters_repr.Proto_003.parametric) ->\n+        set_constants ctxt {\n+          preserved_cycles = old.preserved_cycles ;\n+          blocks_per_cycle = old.blocks_per_cycle ;\n+          blocks_per_commitment = old.blocks_per_commitment ;\n+          blocks_per_roll_snapshot = old.blocks_per_roll_snapshot ;\n+          blocks_per_voting_period = old.blocks_per_voting_period ;\n+          time_between_blocks = old.time_between_blocks ;\n+          endorsers_per_block = old.endorsers_per_block ;\n+          hard_gas_limit_per_operation = old.hard_gas_limit_per_operation ;\n+          hard_gas_limit_per_block = old.hard_gas_limit_per_block ;\n+          proof_of_work_threshold = old.proof_of_work_threshold ;\n+          tokens_per_roll = old.tokens_per_roll ;\n+          michelson_maximum_type_size = old.michelson_maximum_type_size ;\n+          seed_nonce_revelation_tip = old.seed_nonce_revelation_tip ;\n+          origination_size = old.origination_size ;\n+          block_security_deposit = old.block_security_deposit ;\n+          endorsement_security_deposit = old.endorsement_security_deposit ;\n+          block_reward = old.block_reward ;\n+          endorsement_reward = old.endorsement_reward ;\n+          cost_per_byte = old.cost_per_byte ;\n+          hard_storage_limit_per_operation = old.hard_storage_limit_per_operation ;\n+          test_chain_duration = Constants_repr.default.test_chain_duration ;\n+        } >>= fun ctxt ->\n+        return ctxt\n+  end >>=? fun ctxt ->\n   prepare ctxt ~level ~timestamp ~fitness >>=? fun ctxt ->\n   return (previous_proto, ctxt)\n \n\n--- storage_sigs.ml\n+++ storage_sigs.ml\n@@ -50,11 +50,11 @@\n   val get_option: context -> value option tzresult Lwt.t\n \n   (** Allocates the storage bucket and initializes it ; returns a\n-      {!Storage_error Missing_key} if the bucket exists *)\n+      {!Storage_error Existing_key} if the bucket exists *)\n   val init: context -> value -> Raw_context.t tzresult Lwt.t\n \n   (** Updates the content of the bucket ; returns a {!Storage_Error\n-      Existing_key} if the value does not exists *)\n+      Missing_key} if the value does not exists *)\n   val set: context -> value -> Raw_context.t tzresult Lwt.t\n \n   (** Allocates the data and initializes it with a value ; just\n\n--- storage.mli\n+++ storage.mli\n@@ -234,32 +234,38 @@\n     with type value = Voting_period_repr.kind\n      and type t := Raw_context.t\n \n+  (** Expected quorum, in centile of percentage *)\n   module Current_quorum : Single_data_storage\n-    with type value = int32 (* in centile of percentage *)\n+    with type value = int32\n      and type t := Raw_context.t\n \n   module Current_proposal : Single_data_storage\n     with type value = Protocol_hash.t\n      and type t := Raw_context.t\n \n+  (** Sum of all rolls of all delegates. *)\n   module Listings_size : Single_data_storage\n-    with type value = int32 (* total number of rolls in the listing. *)\n-     and type t := Raw_context.t\n-\n+    with type value = int32\n+     and type t := Raw_context.t\n+\n+  (** Contains all delegates with their assigned number of rolls. *)\n   module Listings : Indexed_data_storage\n     with type key = Signature.Public_key_hash.t\n-     and type value = int32 (* number of rolls for the key. *)\n-     and type t := Raw_context.t\n-\n+     and type value = int32\n+     and type t := Raw_context.t\n+\n+  (** Set of protocol proposal with corresponding proposer delegate *)\n   module Proposals : Data_set_storage\n     with type elt = Protocol_hash.t * Signature.Public_key_hash.t\n      and type t := Raw_context.t\n \n+  (** Keeps for each delegate the number of proposed protocols *)\n   module Proposals_count : Indexed_data_storage\n     with type key = Signature.Public_key_hash.t\n      and type value = int\n      and type t := Raw_context.t\n \n+  (** Contains for each delegate its ballot *)\n   module Ballots : Indexed_data_storage\n     with type key = Signature.Public_key_hash.t\n      and type value = Vote_repr.ballot\n\n--- storage.ml\n+++ storage.ml\n@@ -607,50 +607,3 @@\n       end)\n \n end\n-\n-(** Resolver *)\n-\n-let () =\n-  Raw_context.register_resolvers\n-    Contract_hash.b58check_encoding\n-    (fun ctxt p ->\n-       let p = Contract_repr.Index.contract_prefix p in\n-       Contract.Indexed_context.resolve ctxt p >|= fun l ->\n-       List.map\n-         (function\n-           | Contract_repr.Implicit _ -> assert false\n-           | Contract_repr.Originated s -> s)\n-         l) ;\n-  Raw_context.register_resolvers\n-    Ed25519.Public_key_hash.b58check_encoding\n-    (fun ctxt p ->\n-       let p = Contract_repr.Index.pkh_prefix_ed25519 p in\n-       Contract.Indexed_context.resolve ctxt p >|= fun l ->\n-       List.map\n-         (function\n-           | Contract_repr.Implicit (Ed25519 pkh) -> pkh\n-           | Contract_repr.Implicit _ -> assert false\n-           | Contract_repr.Originated _ -> assert false)\n-         l) ;\n-  Raw_context.register_resolvers\n-    Secp256k1.Public_key_hash.b58check_encoding\n-    (fun ctxt p ->\n-       let p = Contract_repr.Index.pkh_prefix_secp256k1 p in\n-       Contract.Indexed_context.resolve ctxt p >|= fun l ->\n-       List.map\n-         (function\n-           | Contract_repr.Implicit (Secp256k1 pkh) -> pkh\n-           | Contract_repr.Implicit _ -> assert false\n-           | Contract_repr.Originated _ -> assert false)\n-         l) ;\n-  Raw_context.register_resolvers\n-    P256.Public_key_hash.b58check_encoding\n-    (fun ctxt p ->\n-       let p = Contract_repr.Index.pkh_prefix_p256 p in\n-       Contract.Indexed_context.resolve ctxt p >|= fun l ->\n-       List.map\n-         (function\n-           | Contract_repr.Implicit (P256 pkh) -> pkh\n-           | Contract_repr.Implicit _ -> assert false\n-           | Contract_repr.Originated _ -> assert false)\n-         l)\n\n--- constants_storage.ml\n+++ constants_storage.ml\n@@ -83,5 +83,8 @@\n let endorsement_reward c =\n   let constants = Raw_context.constants c in\n   constants.endorsement_reward\n+let test_chain_duration c =\n+  let constants = Raw_context.constants c in\n+  constants.test_chain_duration\n let parametric c =\n   Raw_context.constants c\n\n--- roll_storage.mli\n+++ roll_storage.mli\n@@ -95,6 +95,9 @@\n val get_change:\n   Raw_context.t -> Signature.Public_key_hash.t -> Tez_repr.t tzresult Lwt.t\n \n+val update_tokens_per_roll:\n+  Raw_context.t -> Tez_repr.t -> Raw_context.t tzresult Lwt.t\n+\n (**/**)\n \n val get_contract_delegate:\n\n--- roll_storage.ml\n+++ roll_storage.ml\n@@ -194,6 +194,16 @@\n   | None -> return_nil\n   | Some head_roll -> traverse_rolls ctxt head_roll\n \n+let count_rolls ctxt delegate =\n+  Storage.Roll.Delegate_roll_list.get_option ctxt delegate >>=? function\n+  | None -> return 0\n+  | Some head_roll ->\n+      let rec loop acc roll =\n+        Storage.Roll.Successor.get_option ctxt roll >>=? function\n+        | None -> return acc\n+        | Some next -> loop (succ acc) next in\n+      loop 1 head_roll\n+\n let get_change c delegate =\n   Storage.Roll.Delegate_change.get_option c delegate >>=? function\n   | None -> return Tez_repr.zero\n@@ -297,7 +307,7 @@\n       | None ->\n           (* This case is only when called from `set_active`, when creating\n              a contract. *)\n-          return false\n+          return_false\n \n   let add_amount c delegate amount =\n     ensure_inited c delegate >>=? fun c ->\n@@ -480,3 +490,26 @@\n   Storage.Roll.Snapshot_for_cycle.init\n     ctxt (Cycle_repr.succ (Cycle_repr.succ frozen_roll_cycle)) 0 >>=? fun ctxt ->\n   return ctxt\n+\n+let update_tokens_per_roll ctxt new_tokens_per_roll =\n+  let constants = Raw_context.constants ctxt in\n+  let old_tokens_per_roll = constants.tokens_per_roll in\n+  Raw_context.patch_constants ctxt begin fun constants ->\n+    { constants with Constants_repr.tokens_per_roll = new_tokens_per_roll }\n+  end >>= fun ctxt ->\n+  let decrease = Tez_repr.(new_tokens_per_roll < old_tokens_per_roll) in\n+  begin\n+    if decrease then\n+      Lwt.return Tez_repr.(old_tokens_per_roll -? new_tokens_per_roll)\n+    else\n+      Lwt.return Tez_repr.(new_tokens_per_roll -? old_tokens_per_roll)\n+  end >>=? fun abs_diff ->\n+  Storage.Delegates.fold ctxt (Ok ctxt) begin fun pkh ctxt ->\n+    Lwt.return ctxt >>=? fun ctxt ->\n+    count_rolls ctxt pkh >>=? fun rolls ->\n+    Lwt.return Tez_repr.(abs_diff *? Int64.of_int rolls) >>=? fun amount ->\n+    if decrease then\n+      Delegate.add_amount ctxt pkh amount\n+    else\n+      Delegate.remove_amount ctxt pkh amount\n+  end\n\n--- delegate_storage.ml\n+++ delegate_storage.ml\n@@ -46,7 +46,7 @@\n            (req \"kind\" (constant \"freezer\"))\n            (req \"category\" (constant \"rewards\"))\n            (req \"delegate\" Signature.Public_key_hash.encoding)\n-           (req \"level\" Cycle_repr.encoding))\n+           (req \"cycle\" Cycle_repr.encoding))\n         (function Rewards (d, l) -> Some ((), (), d, l) | _ -> None)\n         (fun ((), (), d, l) -> Rewards (d, l)) ;\n       case (Tag 2)\n@@ -55,7 +55,7 @@\n            (req \"kind\" (constant \"freezer\"))\n            (req \"category\" (constant \"fees\"))\n            (req \"delegate\" Signature.Public_key_hash.encoding)\n-           (req \"level\" Cycle_repr.encoding))\n+           (req \"cycle\" Cycle_repr.encoding))\n         (function Fees (d, l) -> Some ((), (), d, l) | _ -> None)\n         (fun ((), (), d, l) -> Fees (d, l)) ;\n       case (Tag 3)\n@@ -64,7 +64,7 @@\n            (req \"kind\" (constant \"freezer\"))\n            (req \"category\" (constant \"deposits\"))\n            (req \"delegate\" Signature.Public_key_hash.encoding)\n-           (req \"level\" Cycle_repr.encoding))\n+           (req \"cycle\" Cycle_repr.encoding))\n         (function Deposits (d, l) -> Some ((), (), d, l) | _ -> None)\n         (fun ((), (), d, l) -> Deposits (d, l)) ]\n \n@@ -624,4 +624,3 @@\n \n let fold = Storage.Delegates.fold\n let list = Storage.Delegates.elements\n-\n\n--- contract_storage.mli\n+++ contract_storage.mli\n@@ -138,3 +138,8 @@\n   val get_opt :\n     Raw_context.t -> Contract_repr.t -> Script_expr_hash.t -> (Raw_context.t * Script_repr.expr option) tzresult Lwt.t\n end\n+\n+(**/**)\n+\n+(** Only for stitching from proto_003 to proto_004 *)\n+val reindex_contract: Raw_context.t -> Raw_context.t tzresult Lwt.t\n\n--- contract_storage.ml\n+++ contract_storage.ml\n@@ -488,20 +488,7 @@\n   | Some balance ->\n       Lwt.return Tez_repr.(amount +? balance) >>=? fun balance ->\n       Storage.Contract.Balance.set c contract balance >>=? fun c ->\n-      Roll_storage.Contract.add_amount c contract amount >>=? fun c ->\n-      begin\n-        match contract with\n-        | Implicit delegate ->\n-            Delegate_storage.registered c delegate >>= fun registered ->\n-            if registered then\n-              Roll_storage.Delegate.set_active c delegate >>=? fun c ->\n-              return c\n-            else\n-              return c\n-        | Originated _ ->\n-            return c\n-      end >>=? fun c ->\n-      return c\n+      Roll_storage.Contract.add_amount c contract amount\n \n let spend c contract amount =\n   is_spendable c contract >>=? fun spendable ->\n@@ -537,3 +524,43 @@\n   let get_opt ctxt contract key =\n     Storage.Contract.Big_map.get_option (ctxt, contract) key\n end\n+\n+\n+(* Only for stitching from proto_003 *)\n+\n+let fold_old_contracts ctxt ~init ~f =\n+  let rec loop depth key acc =\n+    if Compare.Int.(depth < 6) then\n+      Raw_context.fold ctxt key ~init:(Ok acc) ~f:begin fun d acc ->\n+        Lwt.return acc >>=? fun acc ->\n+        match d with\n+        | `Dir d -> loop (depth+1) d acc\n+        | _ -> return acc (* ignore unexpected files *)\n+      end\n+    else\n+      Raw_context.fold ctxt key ~init:(Ok acc) ~f:begin fun d acc ->\n+        Lwt.return acc >>=? fun acc ->\n+        match d with\n+        | `Dir ( \"contracts\" :: \"old_index\" ::\n+                 ([ _ ; _ ; _ ; _ ; _ ; _ ; _ ] as key) as old_path) -> begin\n+            match Contract_repr.old_contract_of_path key with\n+            | None -> return acc (* ignore invalid key *)\n+            | Some contract -> f old_path contract acc\n+          end\n+        | _ -> return acc (* ignore unexpected files *)\n+      end in\n+  loop 0 [ \"contracts\" ; \"old_index\" ] init\n+\n+let reindex_contract ctxt =\n+  Raw_context.copy ctxt\n+    [ \"contracts\" ; \"index\" ]\n+    [ \"contracts\" ; \"old_index\" ] >>=? fun ctxt ->\n+  Raw_context.remove_rec ctxt [ \"contracts\" ; \"index\" ] >>= fun ctxt ->\n+  fold_old_contracts ctxt ~init:ctxt ~f:begin fun old_path contract ctxt ->\n+    let new_path = Contract_repr.Index.to_path contract [] in\n+    Raw_context.copy ctxt\n+      old_path (\"contracts\" :: \"index\" :: new_path) >>=? fun ctxt ->\n+    return ctxt\n+  end >>=? fun ctxt ->\n+  Raw_context.remove_rec ctxt [ \"contracts\" ; \"old_index\" ] >>= fun ctxt ->\n+  return ctxt\n\n--- bootstrap_storage.mli\n+++ bootstrap_storage.mli\n@@ -25,7 +25,9 @@\n \n val init:\n   Raw_context.t ->\n-  typecheck:(Raw_context.t -> Script_repr.t -> Raw_context.t tzresult Lwt.t) ->\n+  typecheck:(Raw_context.t -> Script_repr.t ->\n+             ((Script_repr.t * Contract_storage.big_map_diff option) * Raw_context.t)\n+               tzresult Lwt.t) ->\n   ?ramp_up_cycles:int ->\n   ?no_reward_cycles:int ->\n   Parameters_repr.bootstrap_account list ->\n\n--- bootstrap_storage.ml\n+++ bootstrap_storage.ml\n@@ -39,12 +39,12 @@\n let init_contract ~typecheck ctxt\n     ({ delegate ; amount ; script }: Parameters_repr.bootstrap_contract) =\n   Contract_storage.fresh_contract_from_current_nonce ctxt >>=? fun (ctxt, contract) ->\n-  typecheck ctxt script >>=? fun ctxt ->\n+  typecheck ctxt script >>=? fun (script, ctxt) ->\n   Contract_storage.originate ctxt contract\n     ~balance:amount\n     ~prepaid_bootstrap_storage:true\n     ~manager:Signature.Public_key_hash.zero\n-    ~script:(script, None)\n+    ~script\n     ~delegate:(Some delegate)\n     ~spendable:false\n     ~delegatable:false >>=? fun ctxt ->\n\n--- vote_storage.mli\n+++ vote_storage.mli\n@@ -23,7 +23,9 @@\n (*                                                                           *)\n (*****************************************************************************)\n \n-(** Records a proposal per delegate *)\n+(** Manages all the voting related storage in Storage.Vote.  *)\n+\n+(** Records a protocol proposal with the delegate that proposed it. *)\n val record_proposal:\n   Raw_context.t -> Protocol_hash.t -> Signature.Public_key_hash.t ->\n   Raw_context.t tzresult Lwt.t\n@@ -32,11 +34,13 @@\n   Raw_context.t -> Signature.Public_key_hash.t ->\n   int tzresult Lwt.t\n \n+(** Computes for each proposal how many delegates proposed it. *)\n val get_proposals:\n   Raw_context.t -> int32 Protocol_hash.Map.t tzresult Lwt.t\n \n val clear_proposals: Raw_context.t -> Raw_context.t Lwt.t\n \n+(** Counts of the votes *)\n type ballots = {\n   yay: int32 ;\n   nay: int32 ;\n@@ -46,9 +50,14 @@\n val ballots_encoding : ballots Data_encoding.t\n \n val has_recorded_ballot : Raw_context.t -> Signature.Public_key_hash.t -> bool Lwt.t\n+\n+(** Records a vote for a delegate, returns a {!Storage_error Existing_key} if\n+    the vote was already registered *)\n val record_ballot:\n   Raw_context.t -> Signature.Public_key_hash.t -> Vote_repr.ballot ->\n   Raw_context.t tzresult Lwt.t\n+\n+(** Computes the sum of the current ballots weighted by stake. *)\n val get_ballots: Raw_context.t -> ballots tzresult Lwt.t\n val get_ballot_list :\n   Raw_context.t -> (Signature.Public_key_hash.t * Vote_repr.ballot) list Lwt.t\n@@ -56,10 +65,15 @@\n \n val listings_encoding : (Signature.Public_key_hash.t * int32) list Data_encoding.t\n \n+(** Populates [!Storage.Vote.Listings] using the currently existing rolls and\n+    sets Listings_size. Delegates without rolls are not included in the listing. *)\n val freeze_listings: Raw_context.t -> Raw_context.t tzresult Lwt.t\n val clear_listings: Raw_context.t -> Raw_context.t tzresult Lwt.t\n \n+(** Returns the sum of all rolls of all delegates. *)\n val listing_size: Raw_context.t -> int32 tzresult Lwt.t\n+\n+(** Verifies the presence of a delegate in the listing. *)\n val in_listings:\n   Raw_context.t -> Signature.Public_key_hash.t -> bool Lwt.t\n val get_listings : Raw_context.t -> (Signature.Public_key_hash.t * int32) list Lwt.t\n@@ -78,4 +92,5 @@\n   Raw_context.t -> Protocol_hash.t -> Raw_context.t tzresult Lwt.t\n val clear_current_proposal: Raw_context.t -> Raw_context.t tzresult Lwt.t\n \n+(** Sets the initial quorum to 80% and period kind to proposal. *)\n val init: Raw_context.t -> Raw_context.t tzresult Lwt.t\n\n--- vote_storage.ml\n+++ vote_storage.ml\n@@ -132,6 +132,7 @@\n let clear_current_proposal = Storage.Vote.Current_proposal.delete\n \n let init ctxt =\n+  (* quorum is in centile of a percentage *)\n   Storage.Vote.Current_quorum.init ctxt 80_00l >>=? fun ctxt ->\n   Storage.Vote.Current_period_kind.init ctxt Proposal >>=? fun ctxt ->\n   return ctxt\n\n--- init_storage.ml\n+++ init_storage.ml\n@@ -23,7 +23,14 @@\n (*                                                                           *)\n (*****************************************************************************)\n \n-(* This is the genesis protocol: initialise the state *)\n+let invoice ctxt pkh amount =\n+  let amount = Tez_repr.of_mutez_exn (Int64.(mul 1_000_000L (of_int amount))) in\n+  let recipient =\n+    Contract_repr.implicit_contract\n+      (Signature.Public_key_hash.of_b58check_exn pkh) in\n+  Contract_storage.credit ctxt recipient amount >>=? fun ctxt ->\n+  return ctxt\n+\n let prepare_first_block ctxt ~typecheck ~level ~timestamp ~fitness =\n   Raw_context.prepare_first_block\n     ~level ~timestamp ~fitness ctxt >>=? fun (previous_protocol, ctxt) ->\n@@ -42,44 +49,20 @@\n       Roll_storage.init_first_cycles ctxt >>=? fun ctxt ->\n       Vote_storage.init ctxt >>=? fun ctxt ->\n       Storage.Last_block_priority.init ctxt 0 >>=? fun ctxt ->\n+      Vote_storage.freeze_listings ctxt >>=? fun ctxt ->\n       return ctxt\n-  | Alpha_002 ->\n-      Storage.Delegates.fold ctxt ~init:(Ok ctxt) ~f:begin fun delegate ctxt ->\n-        Lwt.return ctxt >>=? fun ctxt ->\n-        Storage.Contract.Inactive_delegate.mem ctxt\n-          (Contract_repr.implicit_contract delegate) >>= fun inactive ->\n-        if inactive then\n-          return ctxt\n-        else\n-          Storage.Roll.Delegate_roll_list.get_option ctxt delegate >>=? function\n-          | None ->\n-              return ctxt\n-          | Some _ ->\n-              Storage.Active_delegates_with_rolls.add ctxt delegate >>= fun ctxt ->\n-              return ctxt\n-      end >>=? fun ctxt ->\n-      let { Level_repr.cycle = current_cycle } = Raw_context.current_level ctxt in\n-      let { Constants_repr.preserved_cycles } = Raw_context.constants ctxt in\n-      let first_cycle =\n-        match Cycle_repr.sub current_cycle preserved_cycles with\n-        | None -> Cycle_repr.root\n-        | Some first_cycle -> first_cycle in\n-      Storage.Delegates.fold ctxt ~init:(Ok ctxt) ~f:begin fun delegate ctxt ->\n-        Lwt.return ctxt >>=? fun ctxt ->\n-        let rec loop ctxt cycle =\n-          if Cycle_repr.(cycle > current_cycle) then\n-            return ctxt\n-          else\n-            Delegate_storage.has_frozen_balance ctxt delegate cycle >>=? fun has_frozen_balance ->\n-            begin\n-              if has_frozen_balance then\n-                Storage.Delegates_with_frozen_balance.add (ctxt, cycle) delegate\n-              else\n-                Lwt.return ctxt\n-            end >>= fun ctxt ->\n-            loop ctxt (Cycle_repr.succ cycle) in\n-        loop ctxt first_cycle\n-      end >>=? fun ctxt ->\n+  | Alpha_003 ->\n+      Contract_storage.reindex_contract ctxt >>=? fun ctxt ->\n+      (* Update hard gas limits to the new defaults. *)\n+      Raw_context.patch_constants ctxt begin fun constants ->\n+        { constants with\n+          hard_gas_limit_per_operation = Constants_repr.default.hard_gas_limit_per_operation ;\n+          hard_gas_limit_per_block = Constants_repr.default.hard_gas_limit_per_block }\n+      end >>= fun ctxt ->\n+      (* Invoice example: credit the author(s) of this protocol with 100 tez.*)\n+      invoice ctxt\n+        \"tz1iSQEcaGpUn6EW5uAy3XhPiNg7BHMnRSXi\"\n+        100 >>=? fun ctxt ->\n       return ctxt\n \n let prepare ctxt ~level ~timestamp ~fitness =\n\n--- alpha_context.mli\n+++ alpha_context.mli\n@@ -379,6 +379,7 @@\n     endorsement_reward: Tez.t ;\n     cost_per_byte: Tez.t ;\n     hard_storage_limit_per_operation: Z.t ;\n+    test_chain_duration: int64;\n   }\n   val parametric_encoding: parametric Data_encoding.t\n   val parametric: context -> parametric\n@@ -402,6 +403,7 @@\n   val origination_size: context -> int\n   val block_security_deposit: context -> Tez.t\n   val endorsement_security_deposit: context -> Tez.t\n+  val test_chain_duration: context -> int64\n \n   (** All constants: fixed and parametric *)\n   type t = {\n@@ -1116,7 +1118,8 @@\n \n val prepare_first_block:\n   Context.t ->\n-  typecheck:(context -> Script.t -> context tzresult Lwt.t) ->\n+  typecheck:(context -> Script.t ->\n+             ((Script.t * Contract.big_map_diff option) * context) tzresult Lwt.t) ->\n   level:Int32.t ->\n   timestamp:Time.t ->\n   fitness:Fitness.t ->\n\n--- script_ir_translator.mli\n+++ script_ir_translator.mli\n@@ -131,6 +131,6 @@\n   context -> unparsing_mode -> Script_typed_ir.ex_big_map ->\n   (Contract.big_map_diff * context) tzresult Lwt.t\n \n-val erase_big_map_initialization :\n-  context -> unparsing_mode -> Script.t ->\n-  (Script.t * Contract.big_map_diff option * context) tzresult Lwt.t\n+val big_map_initialization :\n+  context -> unparsing_mode -> ex_script ->\n+  (Contract.big_map_diff option * context) tzresult Lwt.t\n\n--- script_ir_translator.ml\n+++ script_ir_translator.ml\n@@ -1617,7 +1617,7 @@\n     let log_stack ctxt loc stack_ty aft =\n       match type_logger, script_instr with\n       | None, _\n-      | Some _, (Seq (-1, _) | Int _ | String _ | Bytes _) -> return ()\n+      | Some _, (Seq (-1, _) | Int _ | String _ | Bytes _) -> return_unit\n       | Some log, (Prim _ | Seq _) ->\n           (* Unparsing for logging done in an unlimited context as this\n              is used only by the client and not the protocol *)\n@@ -1625,7 +1625,7 @@\n           unparse_stack ctxt stack_ty >>=? fun (stack_ty, _) ->\n           unparse_stack ctxt aft >>=? fun (aft, _) ->\n           log loc stack_ty aft;\n-          return ()\n+          return_unit\n     in\n     let return :\n       context -> bef judgement -> (bef judgement * context) tzresult Lwt.t = fun ctxt judgement ->\n@@ -3229,19 +3229,8 @@\n   | Pair_t ((Big_map_t (_, _, _), _, _), _, _), (map, _) -> Some (Ex_bm map)\n   | _, _ -> None\n \n-let erase_big_map_initialization ctxt mode ({ code ; storage } : Script.t) =\n-  Script.force_decode ctxt code >>=? fun (code, ctxt) ->\n-  Script.force_decode ctxt storage >>=? fun (storage, ctxt) ->\n-  Lwt.return @@ parse_toplevel code >>=? fun (_, storage_type, _) ->\n-  Lwt.return @@ parse_storage_ty ctxt storage_type >>=? fun (Ex_ty ty, ctxt) ->\n-  parse_data ctxt ty\n-    (Micheline.root storage) >>=? fun (storage, ctxt) ->\n-  begin\n-    match extract_big_map ty storage with\n-    | None -> return (None, ctxt)\n-    | Some bm -> diff_of_big_map ctxt mode bm >>=? fun (bm, ctxt) ->\n-        return (Some bm, ctxt)\n-  end >>=? fun (bm, ctxt) ->\n-  unparse_data ctxt mode ty storage >>=? fun (storage, ctxt) ->\n-  return ({ code = Script.lazy_expr code ;\n-            storage = Script.lazy_expr (Micheline.strip_locations storage) }, bm, ctxt)\n+let big_map_initialization ctxt mode (Ex_script { storage ; storage_type; _ }) =\n+  match extract_big_map storage_type storage with\n+  | None -> return (None, ctxt)\n+  | Some bm ->\n+      diff_of_big_map ctxt mode bm >>=? fun (bm, ctxt) -> return (Some bm, ctxt)\n\n--- script_tc_errors_registration.ml\n+++ script_tc_errors_registration.ml\n@@ -37,8 +37,8 @@\n        (fun (loc, bef, aft) -> (loc, (bef, aft)))\n        (obj3\n           (req \"location\" Script.location_encoding)\n-          (req \"stackBefore\" stack_enc)\n-          (req \"stackAfter\" stack_enc)))\n+          (req \"stack_before\" stack_enc)\n+          (req \"stack_after\" stack_enc)))\n \n let stack_ty_enc =\n   let open Data_encoding in\n@@ -80,15 +80,15 @@\n   (* Invalid arity *)\n   register_error_kind\n     `Permanent\n-    ~id:\"invalidArityTypeError\"\n-    ~title: \"Invalid arity (typechecking error)\"\n+    ~id:\"michelson_v1.invalid_arity\"\n+    ~title: \"Invalid arity\"\n     ~description:\n       \"In a script or data expression, a primitive was applied \\\n        to an unsupported number of arguments.\"\n     (located (obj3\n-                (req \"primitiveName\" Script.prim_encoding)\n-                (req \"expectedArity\" arity_enc)\n-                (req \"wrongArity\" arity_enc)))\n+                (req \"primitive_name\" Script.prim_encoding)\n+                (req \"expected_arity\" arity_enc)\n+                (req \"wrong_arity\" arity_enc)))\n     (function\n       | Invalid_arity (loc, name, exp, got) ->\n           Some (loc, (name, exp, got))\n@@ -98,7 +98,7 @@\n   (* Missing field *)\n   register_error_kind\n     `Permanent\n-    ~id:\"missingScriptField\"\n+    ~id:\"michelson_v1.missing_script_field\"\n     ~title:\"Script is missing a field (parse error)\"\n     ~description:\n       \"When parsing script, a field was expected, but not provided\"\n@@ -108,13 +108,13 @@\n   (* Invalid primitive *)\n   register_error_kind\n     `Permanent\n-    ~id:\"invalidPrimitiveTypeError\"\n-    ~title: \"Invalid primitive (typechecking error)\"\n+    ~id:\"michelson_v1.invalid_primitive\"\n+    ~title: \"Invalid primitive\"\n     ~description:\n       \"In a script or data expression, a primitive was unknown.\"\n     (located (obj2\n-                (dft \"expectedPrimitiveNames\" (list prim_encoding) [])\n-                (req \"wrongPrimitiveName\" prim_encoding)))\n+                (dft \"expected_primitive_names\" (list prim_encoding) [])\n+                (req \"wrong_primitive_name\" prim_encoding)))\n     (function\n       | Invalid_primitive (loc, exp, got) -> Some (loc, (exp, got))\n       | _ -> None)\n@@ -123,14 +123,14 @@\n   (* Invalid kind *)\n   register_error_kind\n     `Permanent\n-    ~id:\"invalidExpressionKindTypeError\"\n-    ~title: \"Invalid expression kind (typechecking error)\"\n+    ~id:\"michelson_v1.invalid_expression_kind\"\n+    ~title: \"Invalid expression kind\"\n     ~description:\n       \"In a script or data expression, an expression was of the wrong kind \\\n        (for instance a string where only a primitive applications can appear).\"\n     (located (obj2\n-                (req \"expectedKinds\" (list kind_enc))\n-                (req \"wrongKind\" kind_enc)))\n+                (req \"expected_kinds\" (list kind_enc))\n+                (req \"wrong_kind\" kind_enc)))\n     (function\n       | Invalid_kind (loc, exp, got) -> Some (loc, (exp, got))\n       | _ -> None)\n@@ -139,14 +139,14 @@\n   (* Invalid namespace *)\n   register_error_kind\n     `Permanent\n-    ~id:\"invalidPrimitiveNamespaceTypeError\"\n-    ~title: \"Invalid primitive namespace (typechecking error)\"\n+    ~id:\"michelson_v1.invalid_primitive_namespace\"\n+    ~title: \"Invalid primitive namespace\"\n     ~description:\n       \"In a script or data expression, a primitive was of the wrong namespace.\"\n     (located (obj3\n-                (req \"primitiveName\" prim_encoding)\n-                (req \"expectedNamespace\" namespace_enc)\n-                (req \"wrongNamespace\" namespace_enc)))\n+                (req \"primitive_name\" prim_encoding)\n+                (req \"expected_namespace\" namespace_enc)\n+                (req \"wrong_namespace\" namespace_enc)))\n     (function\n       | Invalid_namespace (loc, name, exp, got) -> Some (loc, (name, exp, got))\n       | _ -> None)\n@@ -155,7 +155,7 @@\n   (* Duplicate field *)\n   register_error_kind\n     `Permanent\n-    ~id:\"duplicateScriptField\"\n+    ~id:\"michelson_v1.duplicate_script_field\"\n     ~title: \"Script has a duplicated field (parse error)\"\n     ~description:\n       \"When parsing script, a field was found more than once\"\n@@ -167,7 +167,7 @@\n   (* Unexpected big_map *)\n   register_error_kind\n     `Permanent\n-    ~id:\"unexpectedBigMap\"\n+    ~id:\"michelson_v1.unexpected_bigmap\"\n     ~title: \"Big map in unauthorized position (type error)\"\n     ~description:\n       \"When parsing script, a big_map type was found somewhere else \\\n@@ -179,7 +179,7 @@\n   (* Unexpected operation *)\n   register_error_kind\n     `Permanent\n-    ~id:\"unexpectedOperation\"\n+    ~id:\"michelson_v1.unexpected_operation\"\n     ~title: \"Big map in unauthorized position (type error)\"\n     ~description:\n       \"When parsing script, a operation type was found \\\n@@ -192,7 +192,7 @@\n   (* Unordered map keys *)\n   register_error_kind\n     `Permanent\n-    ~id:\"unorderedMapLiteral\"\n+    ~id:\"michelson_v1.unordered_map_literal\"\n     ~title:\"Invalid map key order\"\n     ~description:\"Map keys must be in strictly increasing order\"\n     (obj2\n@@ -205,7 +205,7 @@\n   (* Duplicate map keys *)\n   register_error_kind\n     `Permanent\n-    ~id:\"duplicateMapKeys\"\n+    ~id:\"michelson_v1.duplicate_map_keys\"\n     ~title:\"Duplicate map keys\"\n     ~description:\"Map literals cannot contain duplicated keys\"\n     (obj2\n@@ -218,7 +218,7 @@\n   (* Unordered set values *)\n   register_error_kind\n     `Permanent\n-    ~id:\"unorderedSetLiteral\"\n+    ~id:\"michelson_v1.unordered_set_literal\"\n     ~title:\"Invalid set value order\"\n     ~description:\"Set values must be in strictly increasing order\"\n     (obj2\n@@ -231,7 +231,7 @@\n   (* Duplicate set values *)\n   register_error_kind\n     `Permanent\n-    ~id:\"duplicateSetValuesInLiteral\"\n+    ~id:\"michelson_v1.duplicate_set_values_in_literal\"\n     ~title:\"Sets literals cannot contain duplicate elements\"\n     ~description:\"Set literals cannot contain duplicate elements, \\\n                   but a duplicae was found while parsing.\"\n@@ -246,8 +246,8 @@\n   (* Fail not in tail position *)\n   register_error_kind\n     `Permanent\n-    ~id:\"failNotInTailPositionTypeError\"\n-    ~title: \"FAIL not in tail position (typechecking error)\"\n+    ~id:\"michelson_v1.fail_not_in_tail_position\"\n+    ~title: \"FAIL not in tail position\"\n     ~description:\n       \"There is non trivial garbage code after a FAIL instruction.\"\n     (located empty)\n@@ -259,15 +259,15 @@\n   (* Undefined binary operation *)\n   register_error_kind\n     `Permanent\n-    ~id:\"undefinedBinopTypeError\"\n-    ~title: \"Undefined binop (typechecking error)\"\n+    ~id:\"michelson_v1.undefined_binop\"\n+    ~title: \"Undefined binop\"\n     ~description:\n       \"A binary operation is called on operands of types \\\n        over which it is not defined.\"\n     (located (obj3\n-                (req \"operatorName\" prim_encoding)\n-                (req \"wrongLeftOperandType\" Script.expr_encoding)\n-                (req \"wrongRightOperandType\" Script.expr_encoding)))\n+                (req \"operator_name\" prim_encoding)\n+                (req \"wrong_left_operand_type\" Script.expr_encoding)\n+                (req \"wrong_right_operand_type\" Script.expr_encoding)))\n     (function\n       | Undefined_binop (loc, n, tyl, tyr) ->\n           Some (loc, (n, tyl, tyr))\n@@ -277,14 +277,14 @@\n   (* Undefined unary operation *)\n   register_error_kind\n     `Permanent\n-    ~id:\"undefinedUnopTypeError\"\n-    ~title: \"Undefined unop (typechecking error)\"\n+    ~id:\"michelson_v1.undefined_unop\"\n+    ~title: \"Undefined unop\"\n     ~description:\n       \"A unary operation is called on an operand of type \\\n        over which it is not defined.\"\n     (located (obj2\n-                (req \"operatorName\" prim_encoding)\n-                (req \"wrongOperandType\" Script.expr_encoding)))\n+                (req \"operator_name\" prim_encoding)\n+                (req \"wrong_operand_type\" Script.expr_encoding)))\n     (function\n       | Undefined_unop (loc, n, ty) ->\n           Some (loc, (n, ty))\n@@ -294,13 +294,13 @@\n   (* Bad return *)\n   register_error_kind\n     `Permanent\n-    ~id:\"badReturnTypeError\"\n-    ~title: \"Bad return (typechecking error)\"\n+    ~id:\"michelson_v1.bad_return\"\n+    ~title: \"Bad return\"\n     ~description:\n       \"Unexpected stack at the end of a lambda or script.\"\n     (located (obj2\n-                (req \"expectedReturnType\" Script.expr_encoding)\n-                (req \"wrongStackType\" stack_ty_enc)))\n+                (req \"expected_return_type\" Script.expr_encoding)\n+                (req \"wrong_stack_type\" stack_ty_enc)))\n     (function\n       | Bad_return (loc, sty, ty) -> Some (loc, (ty, sty))\n       | _ -> None)\n@@ -309,14 +309,14 @@\n   (* Bad stack *)\n   register_error_kind\n     `Permanent\n-    ~id:\"badStackTypeError\"\n-    ~title: \"Bad stack (typechecking error)\"\n+    ~id:\"michelson_v1.bad_stack\"\n+    ~title: \"Bad stack\"\n     ~description:\n       \"The stack has an unexpected length or contents.\"\n     (located (obj3\n-                (req \"primitiveName\" prim_encoding)\n-                (req \"relevantStackPortion\" int16)\n-                (req \"wrongStackType\" stack_ty_enc)))\n+                (req \"primitive_name\" prim_encoding)\n+                (req \"relevant_stack_portion\" int16)\n+                (req \"wrong_stack_type\" stack_ty_enc)))\n     (function\n       | Bad_stack (loc, name, s, sty) -> Some (loc, (name, s, sty))\n       | _ -> None)\n@@ -325,7 +325,7 @@\n   (* Inconsistent annotations *)\n   register_error_kind\n     `Permanent\n-    ~id:\"inconsistentAnnotations\"\n+    ~id:\"michelson_v1.inconsistent_annotations\"\n     ~title:\"Annotations inconsistent between branches\"\n     ~description:\"The annotations on two types could not be merged\"\n     (obj2\n@@ -337,7 +337,7 @@\n   (* Inconsistent field annotations *)\n   register_error_kind\n     `Permanent\n-    ~id:\"inconsistentFieldAnnotations\"\n+    ~id:\"michelson_v1.inconsistent_field_annotations\"\n     ~title:\"Annotations for field accesses is inconsistent\"\n     ~description:\"The specified field does not match the field annotation in the type\"\n     (obj2\n@@ -349,7 +349,7 @@\n   (* Inconsistent type annotations *)\n   register_error_kind\n     `Permanent\n-    ~id:\"inconsistentTypeAnnotations\"\n+    ~id:\"michelson_v1.inconsistent_type_annotations\"\n     ~title:\"Types contain inconsistent annotations\"\n     ~description:\"The two types contain annotations that do not match\"\n     (located (obj2\n@@ -362,7 +362,7 @@\n   (* Unexpected annotation *)\n   register_error_kind\n     `Permanent\n-    ~id:\"unexpectedAnnotation\"\n+    ~id:\"michelson_v1.unexpected_annotation\"\n     ~title:\"An annotation was encountered where no annotation is expected\"\n     ~description:\"A node in the syntax tree was impropperly annotated\"\n     (located empty)\n@@ -372,7 +372,7 @@\n   (* Ungrouped annotations *)\n   register_error_kind\n     `Permanent\n-    ~id:\"ungroupedAnnotations\"\n+    ~id:\"michelson_v1.ungrouped_annotations\"\n     ~title:\"Annotations of the same kind were found spread apart\"\n     ~description:\"Annotations of the same kind must be grouped\"\n     (located empty)\n@@ -382,14 +382,14 @@\n   (* Unmatched branches *)\n   register_error_kind\n     `Permanent\n-    ~id:\"unmatchedBranchesTypeError\"\n-    ~title: \"Unmatched branches (typechecking error)\"\n+    ~id:\"michelson_v1.unmatched_branches\"\n+    ~title: \"Unmatched branches\"\n     ~description:\n       \"At the join point at the end of two code branches \\\n        the stacks have inconsistent lengths or contents.\"\n     (located (obj2\n-                (req \"firstStackType\" stack_ty_enc)\n-                (req \"otherStackType\" stack_ty_enc)))\n+                (req \"first_stack_type\" stack_ty_enc)\n+                (req \"other_stack_type\" stack_ty_enc)))\n     (function\n       | Unmatched_branches (loc, stya, styb) ->\n           Some (loc, (stya, styb))\n@@ -399,12 +399,12 @@\n   (* Bad stack item *)\n   register_error_kind\n     `Permanent\n-    ~id:\"badStackItemTypeError\"\n-    ~title: \"Bad stack item (typechecking error)\"\n+    ~id:\"michelson_v1.bad_stack_item\"\n+    ~title: \"Bad stack item\"\n     ~description:\n       \"The type of a stack item is unexpected \\\n        (this error is always accompanied by a more precise one).\"\n-    (obj1 (req \"itemLevel\" int16))\n+    (obj1 (req \"item_level\" int16))\n     (function\n       | Bad_stack_item n -> Some n\n       | _ -> None)\n@@ -413,8 +413,8 @@\n   (* SELF in lambda *)\n   register_error_kind\n     `Permanent\n-    ~id:\"selfInLambda\"\n-    ~title: \"SELF instruction in lambda (typechecking error)\"\n+    ~id:\"michelson_v1.self_in_lambda\"\n+    ~title: \"SELF instruction in lambda\"\n     ~description:\n       \"A SELF instruction was encountered in a lambda expression.\"\n     (located empty)\n@@ -426,8 +426,8 @@\n   (* Bad stack length *)\n   register_error_kind\n     `Permanent\n-    ~id:\"inconsistentStackLengthsTypeError\"\n-    ~title: \"Inconsistent stack lengths (typechecking error)\"\n+    ~id:\"michelson_v1.inconsistent_stack_lengths\"\n+    ~title: \"Inconsistent stack lengths\"\n     ~description:\n       \"A stack was of an unexpected length \\\n        (this error is always in the context of a located error).\"\n@@ -441,13 +441,13 @@\n   (* Invalid constant *)\n   register_error_kind\n     `Permanent\n-    ~id:\"invalidConstantTypeError\"\n-    ~title: \"Invalid constant (typechecking error)\"\n+    ~id:\"michelson_v1.invalid_constant\"\n+    ~title: \"Invalid constant\"\n     ~description:\n       \"A data expression was invalid for its expected type.\"\n     (located (obj2\n-                (req \"expectedType\" Script.expr_encoding)\n-                (req \"wrongExpression\" Script.expr_encoding)))\n+                (req \"expected_type\" Script.expr_encoding)\n+                (req \"wrong_expression\" Script.expr_encoding)))\n     (function\n       | Invalid_constant (loc, expr, ty) ->\n           Some (loc, (ty, expr))\n@@ -457,8 +457,8 @@\n   (* Invalid contract *)\n   register_error_kind\n     `Permanent\n-    ~id:\"invalidContractTypeError\"\n-    ~title: \"Invalid contract (typechecking error)\"\n+    ~id:\"michelson_v1.invalid_contract\"\n+    ~title: \"Invalid contract\"\n     ~description:\n       \"A script or data expression references a contract that does not \\\n        exist or assumes a wrong type for an existing contract.\"\n@@ -472,12 +472,12 @@\n   (* Comparable type expected *)\n   register_error_kind\n     `Permanent\n-    ~id:\"comparableTypeExpectedTypeError\"\n-    ~title: \"Comparable type expected (typechecking error)\"\n+    ~id:\"michelson_v1.comparable_type_expected\"\n+    ~title: \"Comparable type expected\"\n     ~description:\n       \"A non comparable type was used in a place where \\\n        only comparable types are accepted.\"\n-    (located (obj1 (req \"wrongType\" Script.expr_encoding)))\n+    (located (obj1 (req \"wrong_type\" Script.expr_encoding)))\n     (function\n       | Comparable_type_expected (loc, ty) -> Some (loc, ty)\n       | _ -> None)\n@@ -486,16 +486,16 @@\n   (* Inconsistent types *)\n   register_error_kind\n     `Permanent\n-    ~id:\"InconsistentTypesTypeError\"\n-    ~title: \"Inconsistent types (typechecking error)\"\n+    ~id:\"michelson_v1.inconsistent_types\"\n+    ~title: \"Inconsistent types\"\n     ~description:\n       \"This is the basic type clash error, \\\n        that appears in several places where the equality of \\\n        two types have to be proven, it is always accompanied \\\n        with another error that provides more context.\"\n     (obj2\n-       (req \"firstType\" Script.expr_encoding)\n-       (req \"otherType\" Script.expr_encoding))\n+       (req \"first_type\" Script.expr_encoding)\n+       (req \"other_type\" Script.expr_encoding))\n     (function\n       | Inconsistent_types (tya, tyb) -> Some (tya, tyb)\n       | _ -> None)\n@@ -504,13 +504,13 @@\n   (* Invalid map body *)\n   register_error_kind\n     `Permanent\n-    ~id:\"invalidMapBody\"\n+    ~id:\"michelson_v1.invalid_map_body\"\n     ~title: \"Invalid map body\"\n     ~description:\n       \"The body of a map block did not match the expected type\"\n     (obj2\n        (req \"loc\" Script.location_encoding)\n-       (req \"bodyType\" stack_ty_enc))\n+       (req \"body_type\" stack_ty_enc))\n     (function\n       | Invalid_map_body (loc, stack) -> Some (loc, stack)\n       | _ -> None)\n@@ -518,7 +518,7 @@\n   (* Invalid map block FAIL *)\n   register_error_kind\n     `Permanent\n-    ~id:\"invalidMapBlockFail\"\n+    ~id:\"michelson_v1.invalid_map_block_fail\"\n     ~title:\"FAIL instruction occurred as body of map block\"\n     ~description:\"FAIL cannot be the only instruction in the body. \\\n                   The propper type of the return list cannot be inferred.\"\n@@ -530,15 +530,15 @@\n   (* Invalid ITER body *)\n   register_error_kind\n     `Permanent\n-    ~id:\"invalidIterBody\"\n+    ~id:\"michelson_v1.invalid_iter_body\"\n     ~title:\"ITER body returned wrong stack type\"\n     ~description:\"The body of an ITER instruction \\\n                   must result in the same stack type as before \\\n                   the ITER.\"\n     (obj3\n        (req \"loc\" Script.location_encoding)\n-       (req \"befStack\" stack_ty_enc)\n-       (req \"aftStack\" stack_ty_enc))\n+       (req \"bef_stack\" stack_ty_enc)\n+       (req \"aft_stack\" stack_ty_enc))\n     (function\n       | Invalid_iter_body (loc, bef, aft) -> Some (loc, bef, aft)\n       | _ -> None)\n@@ -546,13 +546,13 @@\n   (* Type too large *)\n   register_error_kind\n     `Permanent\n-    ~id:\"typeTooLarge\"\n+    ~id:\"michelson_v1.type_too_large\"\n     ~title:\"Stack item type too large\"\n     ~description:\"An instruction generated a type larger than the limit.\"\n     (obj3\n        (req \"loc\" Script.location_encoding)\n-       (req \"typeSize\" uint16)\n-       (req \"maximumTypeSize\" uint16))\n+       (req \"type_size\" uint16)\n+       (req \"maximum_type_size\" uint16))\n     (function\n       | Type_too_large (loc, ts, maxts) -> Some (loc, ts, maxts)\n       | _ -> None)\n@@ -561,16 +561,16 @@\n   (* Ill typed data *)\n   register_error_kind\n     `Permanent\n-    ~id:\"illTypedDataTypeError\"\n-    ~title: \"Ill typed data (typechecking error)\"\n+    ~id:\"michelson_v1.ill_typed_data\"\n+    ~title: \"Ill typed data\"\n     ~description:\n       \"The toplevel error thrown when trying to typecheck \\\n        a data expression against a given type \\\n        (always followed by more precise errors).\"\n     (obj3\n        (opt \"identifier\" string)\n-       (req \"expectedType\" Script.expr_encoding)\n-       (req \"illTypedExpression\" Script.expr_encoding))\n+       (req \"expected_type\" Script.expr_encoding)\n+       (req \"ill_typed_expression\" Script.expr_encoding))\n     (function\n       | Ill_typed_data (name, expr, ty) -> Some (name, ty,  expr)\n       | _ -> None)\n@@ -578,14 +578,14 @@\n   (* Ill formed type *)\n   register_error_kind\n     `Permanent\n-    ~id:\"illFormedTypeTypeError\"\n-    ~title: \"Ill formed type (typechecking error)\"\n+    ~id:\"michelson_v1.ill_formed_type\"\n+    ~title: \"Ill formed type\"\n     ~description:\n       \"The toplevel error thrown when trying to parse a type expression \\\n        (always followed by more precise errors).\"\n     (obj3\n        (opt \"identifier\" string)\n-       (req \"illFormedExpression\" Script.expr_encoding)\n+       (req \"ill_formed_expression\" Script.expr_encoding)\n        (req \"location\" Script.location_encoding))\n     (function\n       | Ill_formed_type (name, expr, loc) -> Some (name, expr, loc)\n@@ -595,15 +595,15 @@\n   (* Ill typed contract *)\n   register_error_kind\n     `Permanent\n-    ~id:\"illTypedContractTypeError\"\n-    ~title: \"Ill typed contract (typechecking error)\"\n+    ~id:\"michelson_v1.ill_typed_contract\"\n+    ~title: \"Ill typed contract\"\n     ~description:\n       \"The toplevel error thrown when trying to typecheck \\\n        a contract code against given input, output and storage types \\\n        (always followed by more precise errors).\"\n     (obj2\n-       (req \"illTypedCode\" Script.expr_encoding)\n-       (req \"typeMap\" type_map_enc))\n+       (req \"ill_typed_code\" Script.expr_encoding)\n+       (req \"type_map\" type_map_enc))\n     (function\n       | Ill_typed_contract (expr, type_map) ->\n           Some (expr, type_map)\n@@ -613,7 +613,7 @@\n   (* Cannot serialize error *)\n   register_error_kind\n     `Temporary\n-    ~id:\"cannotSerializeError\"\n+    ~id:\"michelson_v1.cannot_serialize_error\"\n     ~title:\"Not enough gas to serialize error\"\n     ~description:\"The error was too big to be serialized with \\\n                   the provided gas\"\n\n--- script_interpreter.ml\n+++ script_interpreter.ml\n@@ -55,8 +55,8 @@\n   (* Reject *)\n   register_error_kind\n     `Temporary\n-    ~id:\"scriptRejectedRuntimeError\"\n-    ~title: \"Script failed (runtime script error)\"\n+    ~id:\"michelson_v1.script_rejected\"\n+    ~title: \"Script failed\"\n     ~description: \"A FAILWITH instruction was reached\"\n     (obj3\n        (req \"location\" Script.location_encoding)\n@@ -67,7 +67,7 @@\n   (* Overflow *)\n   register_error_kind\n     `Temporary\n-    ~id:\"scriptOverflowRuntimeError\"\n+    ~id:\"michelson_v1.script_overflow\"\n     ~title: \"Script failed (overflow error)\"\n     ~description: \"A FAIL instruction was reached due to the detection of an overflow\"\n     (obj2\n@@ -78,12 +78,12 @@\n   (* Runtime contract error *)\n   register_error_kind\n     `Temporary\n-    ~id:\"scriptRuntimeError\"\n+    ~id:\"michelson_v1.runtime_error\"\n     ~title: \"Script runtime error\"\n     ~description: \"Toplevel error for all runtime script errors\"\n     (obj2\n-       (req \"contractHandle\" Contract.encoding)\n-       (req \"contractCode\" Script.expr_encoding))\n+       (req \"contract_handle\" Contract.encoding)\n+       (req \"contract_code\" Script.expr_encoding))\n     (function\n       | Runtime_contract_error (contract, expr) ->\n           Some (contract, expr)\n@@ -93,7 +93,7 @@\n   (* Bad contract parameter *)\n   register_error_kind\n     `Permanent\n-    ~id:\"badContractParameter\"\n+    ~id:\"michelson_v1.bad_contract_parameter\"\n     ~title:\"Contract supplied an invalid parameter\"\n     ~description:\"Either no parameter was supplied to a contract with \\\n                   a non-unit parameter type, a non-unit parameter was \\\n@@ -105,7 +105,7 @@\n   (* Cannot serialize log *)\n   register_error_kind\n     `Temporary\n-    ~id:\"cannotSerializeLog\"\n+    ~id:\"michelson_v1.cannot_serialize_log\"\n     ~title:\"Not enough gas to serialize execution trace\"\n     ~description:\"Execution trace with stacks was to big to be serialized with \\\n                   the provided gas\"\n@@ -115,7 +115,7 @@\n   (* Cannot serialize failure *)\n   register_error_kind\n     `Temporary\n-    ~id:\"cannotSerializeFailure\"\n+    ~id:\"michelson_v1.cannot_serialize_failure\"\n     ~title:\"Not enough gas to serialize argument of FAILWITH\"\n     ~description:\"Argument of FAILWITH was too big to be serialized with \\\n                   the provided gas\"\n@@ -125,7 +125,7 @@\n   (* Cannot serialize storage *)\n   register_error_kind\n     `Temporary\n-    ~id:\"cannotSerializeStorage\"\n+    ~id:\"michelson_v1.cannot_serialize_storage\"\n     ~title:\"Not enough gas to serialize execution storage\"\n     ~description:\"The returned storage was too big to be serialized with \\\n                   the provided gas\"\n\n--- amendment.mli\n+++ amendment.mli\n@@ -23,9 +23,35 @@\n (*                                                                           *)\n (*****************************************************************************)\n \n+(**\n+   Only delegates with at least one roll take part in the amendment procedure.\n+   It works as follows:\n+   - Proposal period: delegates can submit protocol amendment proposals using\n+     the proposal operation. At the end of a proposal period, the proposal with\n+     most supporters is selected and we move to a testing_vote period.\n+     If there are no proposals, or a tie between proposals, a new proposal\n+     period starts.\n+   - Testing_vote period: delegates can cast votes to test or not the winning\n+     proposal using the ballot operation.\n+     At the end of a testing_vote period if participation reaches the quorum\n+     and the proposal has a supermajority in favor, we proceed to a testing\n+     period. Otherwise we go back to a proposal period.\n+     In any case, if there is enough participation the quorum is updated.\n+   - Testing period: a test chain is forked for the lengh of the period.\n+     At the end of a testing period we move to a promotion_vote period.\n+   - Promotion_vote period: delegates can cast votes to promote or not the\n+     tested proposal using the ballot operation.\n+     At the end of a promotion_vote period if participation reaches the quorum\n+     and the tested proposal has a supermajority in favor, it is activated as\n+     the new protocol. Otherwise we go back to a proposal period.\n+     In any case, if there is enough participation the quorum is updated.\n+*)\n+\n open Alpha_context\n \n-val may_start_new_voting_cycle:\n+(** If at the end of a voting period, moves to the next one following\n+    the state machine of the amendment procedure. *)\n+val may_start_new_voting_period:\n   context -> context tzresult Lwt.t\n \n type error +=\n@@ -34,6 +60,9 @@\n   | Too_many_proposals\n   | Empty_proposal\n \n+(** Records a list of proposals for a delegate.\n+    @raise Unexpected_proposal if [ctxt] is not in a proposal period.\n+    @raise Unauthorized_proposal if [delegate] is not in the listing. *)\n val record_proposals:\n   context ->\n   public_key_hash -> Protocol_hash.t list ->\n\n--- amendment.ml\n+++ amendment.ml\n@@ -25,8 +25,8 @@\n \n open Alpha_context\n \n-let () = ()\n-\n+(** Returns the proposal submitted by the most delegates.\n+    Returns None in case of a tie or if there are no proposals. *)\n let select_winning_proposal proposals =\n   let merge proposal vote winners =\n     match winners with\n@@ -43,28 +43,43 @@\n   | Some ([proposal], _) -> Some proposal\n   | Some _ -> None (* in case of a tie, lets do nothing. *)\n \n+(** A proposal is approved if it has supermajority and the participation reaches\n+    the current quorum.\n+    Supermajority means the yays are more 8/10 of casted votes.\n+    The participation is the ratio of all received votes, including passes, with\n+    respect to the number of possible votes. The quorum starts at 80% and at\n+    each vote is updated using the last expected quorum and the current\n+    participation with the following weights:\n+    newQ = oldQ * 8/10 + participation * 2/10 *)\n let check_approval_and_update_quorum ctxt =\n   Vote.get_ballots ctxt >>=? fun ballots ->\n   Vote.listing_size ctxt >>=? fun maximum_vote ->\n   Vote.get_current_quorum ctxt >>=? fun expected_quorum ->\n-  (* FIXME check overflow ??? *)\n-  let casted_vote = Int32.add ballots.yay ballots.nay in\n-  let actual_vote = Int32.add casted_vote ballots.pass in\n-  let actual_quorum =\n-    Int32.div (Int32.mul actual_vote 100_00l) maximum_vote in\n-  let supermajority = Int32.div (Int32.mul 8l casted_vote) 10l in\n+  (* Note overflows: considering a maximum of 8e8 tokens, with roll size as\n+     small as 1e3, there is a maximum of 8e5 rolls and thus votes.\n+     In 'participation' an Int64 is used because in the worst case 'all_votes is\n+     8e5 and after the multiplication is 8e9, making it potentially overflow a\n+     signed Int32 which is 2e9. *)\n+  let casted_votes = Int32.add ballots.yay ballots.nay in\n+  let all_votes = Int32.add casted_votes ballots.pass in\n+  let supermajority = Int32.div (Int32.mul 8l casted_votes) 10l in\n+  let participation = (* in centile of percentage *)\n+    Int64.to_int32\n+      (Int64.div\n+         (Int64.mul (Int64.of_int32 all_votes) 100_00L)\n+         (Int64.of_int32 maximum_vote)) in\n+  let outcome = Compare.Int32.(participation >= expected_quorum &&\n+                               ballots.yay >= supermajority) in\n   let updated_quorum =\n-    Int32.div\n-      (Int32.add (Int32.mul 8l expected_quorum)\n-         (Int32.mul 2l actual_quorum))\n-      10l in\n+    Int32.div (Int32.add (Int32.mul 8l expected_quorum) (Int32.mul 2l participation)) 10l in\n   Vote.set_current_quorum ctxt updated_quorum >>=? fun ctxt ->\n-  return\n-    (ctxt,\n-     Compare.Int32.(actual_quorum >= expected_quorum\n-                    && ballots.yay >= supermajority))\n-\n-let start_new_voting_cycle ctxt =\n+  return (ctxt, outcome)\n+\n+(** Implements the state machine of the amendment procedure.\n+    Note that [freeze_listings], that computes the vote weight of each delegate,\n+    is run at the beginning of each voting period.\n+*)\n+let start_new_voting_period ctxt =\n   Vote.get_current_period_kind ctxt >>=? function\n   | Proposal -> begin\n       Vote.get_proposals ctxt >>=? fun proposals ->\n@@ -86,7 +101,7 @@\n       Vote.clear_listings ctxt >>=? fun ctxt ->\n       if approved then\n         let expiration = (* in two days maximum... *)\n-          Time.add (Timestamp.current ctxt) (Int64.mul 48L 3600L) in\n+          Time.add (Timestamp.current ctxt) (Constants.test_chain_duration ctxt) in\n         Vote.get_current_proposal ctxt >>=? fun proposal ->\n         fork_test_chain ctxt proposal expiration >>= fun ctxt ->\n         Vote.set_current_period_kind ctxt Testing >>=? fun ctxt ->\n@@ -212,7 +227,7 @@\n let record_proposals ctxt delegate proposals =\n   begin match proposals with\n     | [] -> fail Empty_proposal\n-    | _ :: _ -> return ()\n+    | _ :: _ -> return_unit\n   end >>=? fun () ->\n   Vote.get_current_period_kind ctxt >>=? function\n   | Proposal ->\n@@ -252,9 +267,9 @@\n   Compare.Int32.(Int32.succ l.Level.voting_period_position =\n                  Constants.blocks_per_voting_period ctxt )\n \n-let may_start_new_voting_cycle ctxt =\n+let may_start_new_voting_period ctxt =\n   let level = Level.current ctxt in\n   if last_of_a_voting_period ctxt level then\n-    start_new_voting_cycle ctxt\n+    start_new_voting_period ctxt\n   else\n     return ctxt\n\n--- apply.ml\n+++ apply.ml\n@@ -33,6 +33,8 @@\n type error += Invalid_endorsement_level\n type error += Invalid_commitment of { expected: bool }\n type error += Internal_operation_replay of packed_internal_operation\n+type error += Cannot_originate_spendable_smart_contract (* `Permanent *)\n+type error += Cannot_originate_non_spendable_account (* `Permanent *)\n \n type error += Invalid_double_endorsement_evidence (* `Permanent *)\n type error += Inconsistent_double_endorsement_evidence\n@@ -133,6 +135,30 @@\n     Operation.internal_operation_encoding\n     (function Internal_operation_replay op -> Some op | _ -> None)\n     (fun op -> Internal_operation_replay op) ;\n+  register_error_kind\n+    `Permanent\n+    ~id:\"cannot_originate_non_spendable_account\"\n+    ~title:\"Cannot originate non spendable account\"\n+    ~description:\"An origination was attempted \\\n+                  that would create a non spendable, non scripted contract\"\n+    ~pp:(fun ppf () ->\n+        Format.fprintf ppf \"It is not possible anymore to originate \\\n+                            a non scripted contract that is not spendable.\")\n+    Data_encoding.empty\n+    (function Cannot_originate_non_spendable_account -> Some () | _ -> None)\n+    (fun () -> Cannot_originate_non_spendable_account) ;\n+  register_error_kind\n+    `Permanent\n+    ~id:\"cannot_originate_spendable_smart_contract\"\n+    ~title:\"Cannot originate spendable smart contract\"\n+    ~description:\"An origination was attempted \\\n+                  that would create a spendable scripted contract\"\n+    ~pp:(fun ppf () ->\n+        Format.fprintf ppf \"It is not possible anymore to originate \\\n+                            a scripted contract that is spendable.\")\n+    Data_encoding.empty\n+    (function Cannot_originate_spendable_smart_contract -> Some () | _ -> None)\n+    (fun () -> Cannot_originate_spendable_smart_contract) ;\n   register_error_kind\n     `Permanent\n     ~id:\"block.invalid_double_endorsement_evidence\"\n@@ -460,15 +486,22 @@\n     | Origination { manager ; delegate ; script ; preorigination ;\n                     spendable ; delegatable ; credit } ->\n         begin match script with\n-          | None -> return (None, ctxt)\n+          | None ->\n+              if spendable then\n+                return (None, ctxt)\n+              else\n+                fail Cannot_originate_non_spendable_account\n           | Some script ->\n-              Script.force_decode ctxt script.storage >>=? fun (unparsed_storage, ctxt) -> (* see [note] *)\n-              Lwt.return (Gas.consume ctxt (Script.deserialized_cost unparsed_storage)) >>=? fun ctxt ->\n-              Script.force_decode ctxt script.code >>=? fun (unparsed_code, ctxt) -> (* see [note] *)\n-              Lwt.return (Gas.consume ctxt (Script.deserialized_cost unparsed_code)) >>=? fun ctxt ->\n-              Script_ir_translator.parse_script ctxt script >>=? fun (_, ctxt) ->\n-              Script_ir_translator.erase_big_map_initialization ctxt Optimized script >>=? fun (script, big_map_diff, ctxt) ->\n-              return (Some (script, big_map_diff), ctxt)\n+              if spendable then\n+                fail Cannot_originate_spendable_smart_contract\n+              else\n+                Script.force_decode ctxt script.storage >>=? fun (unparsed_storage, ctxt) -> (* see [note] *)\n+                Lwt.return (Gas.consume ctxt (Script.deserialized_cost unparsed_storage)) >>=? fun ctxt ->\n+                Script.force_decode ctxt script.code >>=? fun (unparsed_code, ctxt) -> (* see [note] *)\n+                Lwt.return (Gas.consume ctxt (Script.deserialized_cost unparsed_code)) >>=? fun ctxt ->\n+                Script_ir_translator.parse_script ctxt script >>=? fun (ex_script, ctxt) ->\n+                Script_ir_translator.big_map_initialization ctxt Optimized ex_script >>=? fun (big_map_diff, ctxt) ->\n+                return (Some (script, big_map_diff), ctxt)\n         end >>=? fun (script, ctxt) ->\n         spend ctxt source credit >>=? fun ctxt ->\n         begin match preorigination with\n@@ -1020,7 +1053,7 @@\n   (* end of cycle *)\n   may_snapshot_roll ctxt >>=? fun ctxt ->\n   may_start_new_cycle ctxt >>=? fun (ctxt, balance_updates, deactivated) ->\n-  Amendment.may_start_new_voting_cycle ctxt >>=? fun ctxt ->\n+  Amendment.may_start_new_voting_period ctxt >>=? fun ctxt ->\n   let cycle = (Level.current ctxt).cycle in\n   let balance_updates =\n     Delegate.(cleanup_balance_updates\n\n--- helpers_services.mli\n+++ helpers_services.mli\n@@ -39,7 +39,8 @@\n \n   val run_code:\n     'a #RPC_context.simple ->\n-    'a -> Script.expr -> (Script.expr * Script.expr * Tez.t) ->\n+    'a -> Script.expr ->\n+    (Script.expr * Script.expr * Tez.t * Contract.t option * Contract.t option * Z.t option) ->\n     (Script.expr *\n      packed_internal_operation list *\n      Contract.big_map_diff option) shell_tzresult Lwt.t\n@@ -47,7 +48,7 @@\n   val trace_code:\n     'a #RPC_context.simple ->\n     'a -> Script.expr ->\n-    (Script.expr * Script.expr * Tez.t) ->\n+    (Script.expr * Script.expr * Tez.t * Contract.t option * Contract.t option* Z.t option) ->\n     (Script.expr *\n      packed_internal_operation list *\n      Script_interpreter.execution_trace *\n\n--- helpers_services.ml\n+++ helpers_services.ml\n@@ -59,11 +59,14 @@\n     let path = RPC_path.(path / \"scripts\")\n \n     let run_code_input_encoding =\n-      (obj4\n+      (obj7\n          (req \"script\" Script.expr_encoding)\n          (req \"storage\" Script.expr_encoding)\n          (req \"input\" Script.expr_encoding)\n-         (req \"amount\" Tez.encoding))\n+         (req \"amount\" Tez.encoding)\n+         (opt \"source\" Contract.encoding)\n+         (opt \"payer\" Contract.encoding)\n+         (opt \"gas\" z))\n \n     let trace_encoding =\n       def \"scripted.trace\" @@\n@@ -167,30 +170,46 @@\n         ~script: (script, None) >>=? fun ctxt ->\n       return (ctxt, dummy_contract) in\n     register0 S.run_code begin fun ctxt ()\n-      (code, storage, parameter, amount) ->\n+      (code, storage, parameter, amount, source, payer, gas) ->\n       let storage = Script.lazy_expr storage in\n       let code = Script.lazy_expr code in\n       originate_dummy_contract ctxt { storage ; code } >>=? fun (ctxt, dummy_contract) ->\n-      let ctxt = Gas.set_limit ctxt (Constants.hard_gas_limit_per_operation ctxt) in\n+      let source, payer = match source, payer with\n+        | Some source, Some payer -> source, payer\n+        | Some source, None -> source, source\n+        | None, Some payer -> payer, payer\n+        | None, None -> dummy_contract, dummy_contract in\n+      let gas = match gas with\n+        | Some gas -> gas\n+        | None -> Constants.hard_gas_limit_per_operation ctxt in\n+      let ctxt = Gas.set_limit ctxt gas in\n       Script_interpreter.execute\n         ctxt Readable\n-        ~source:dummy_contract\n-        ~payer:dummy_contract\n+        ~source\n+        ~payer\n         ~self:(dummy_contract, { storage ; code })\n         ~amount ~parameter\n       >>=? fun { Script_interpreter.storage ; operations ; big_map_diff ; _ } ->\n       return (storage, operations, big_map_diff)\n     end ;\n     register0 S.trace_code begin fun ctxt ()\n-      (code, storage, parameter, amount) ->\n+      (code, storage, parameter, amount, source, payer, gas) ->\n       let storage = Script.lazy_expr storage in\n       let code = Script.lazy_expr code in\n       originate_dummy_contract ctxt { storage ; code } >>=? fun (ctxt, dummy_contract) ->\n-      let ctxt = Gas.set_limit ctxt (Constants.hard_gas_limit_per_operation ctxt) in\n+      let source, payer = match source, payer with\n+        | Some source, Some payer -> source, payer\n+        | Some source, None -> source, source\n+        | None, Some payer -> payer, payer\n+        | None, None -> dummy_contract, dummy_contract in\n+      let gas = match gas with\n+        | Some gas -> gas\n+        | None -> Constants.hard_gas_limit_per_operation ctxt in\n+      let ctxt = Gas.set_limit ctxt gas in\n       Script_interpreter.trace\n         ctxt Readable\n-        ~source:dummy_contract\n-        ~payer:dummy_contract\n+        ~source\n+        ~payer\n         ~self:(dummy_contract, { storage ; code })\n         ~amount ~parameter\n       >>=? fun ({ Script_interpreter.storage ; operations ; big_map_diff ; _ }, trace) ->\n@@ -305,13 +324,13 @@\n \n     end\n \n-  let run_code ctxt block code (storage, input, amount) =\n+  let run_code ctxt block code (storage, input, amount, source, payer, gas) =\n     RPC_context.make_call0 S.run_code ctxt\n-      block () (code, storage, input, amount)\n-\n-  let trace_code ctxt block code (storage, input, amount) =\n+      block () (code, storage, input, amount, source, payer, gas)\n+\n+  let trace_code ctxt block code (storage, input, amount, source, payer, gas) =\n     RPC_context.make_call0 S.trace_code ctxt\n-      block () (code, storage, input, amount)\n+      block () (code, storage, input, amount, source, payer, gas)\n \n   let typecheck_code ctxt block =\n     RPC_context.make_call0 S.typecheck_code ctxt block ()\n\n--- voting_services.ml\n+++ voting_services.ml\n@@ -111,8 +111,8 @@\n   register0 S.current_proposal begin fun ctxt () () ->\n     (* this would be better implemented using get_option in get_current_proposal *)\n     Vote.get_current_proposal ctxt >>= function\n-    | Ok p -> return (Some p)\n-    | Error [Raw_context.Storage_error (Missing_key _)] -> return None\n+    | Ok p -> return_some p\n+    | Error [Raw_context.Storage_error (Missing_key _)] -> return_none\n     | (Error _ as e) -> Lwt.return e\n   end\n \n\n--- main.ml\n+++ main.ml\n@@ -298,8 +298,9 @@\n   let fitness = block_header.fitness in\n   let timestamp = block_header.timestamp in\n   let typecheck (ctxt:Alpha_context.context) (script:Alpha_context.Script.t) =\n-    Script_ir_translator.parse_script ctxt script >>=? fun (_ex_script, ctxt) ->\n-    return ctxt\n+    Script_ir_translator.parse_script ctxt script >>=? fun (ex_script, ctxt) ->\n+    Script_ir_translator.big_map_initialization ctxt Optimized ex_script >>=? fun (big_map_diff, ctxt) ->\n+    return ((script, big_map_diff), ctxt)\n   in\n   Alpha_context.prepare_first_block\n     ~typecheck\n";
  var diffHtml = Diff2Html.getPrettyHtml(text, {
    inputFormat: 'diff',
    showFiles: true,
    matching: 'lines',
    outputFormat: 'side-by-side'
  });
  document.getElementById("diff").innerHTML = diffHtml;
</script>
</body>
</html>